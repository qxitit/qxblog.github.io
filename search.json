[{"url":"/qxblog.github.io/2025/04/22/Java0422/","content":"title: Java04222知识点date: 2025-4-22\nJava04222知识点Java包装类型的缓存机制8种基本类型对应的包装类型是 Byte、Short、Integer、Long、Float、Double、Character、Boolean。\n缓存机制：Byte, Short, Integer, Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 TRUE or FALSE。\n简单理解：即对于创建一个在范围内的数据，如果再次创建一个在范围内的数据话，可以直接引用此数据。如果创建一个在范围外的数据，将会创建新的对象，无法使用此缓存机制。\n详细理解：\n代码：\nInteger i1 = 33;Integer i2 = 33;System.out.println(i1 == i2);\n解释：Java 会对处于 -128 到 127 范围的Integer对象进行缓存。当你以Integer i &#x3D; 33;这种方式创建Integer对象时，Java 首先会查看缓存里是否存在值为 33 的Integer对象，若存在就直接返回该对象的引用；若不存在，就创建一个新的Integer对象并将其存入缓存。\n代码：\nInteger i3 = 128;Integer i4 = 128;System.out.println(i3 == i4);\n解释：这里的 128 超出了 -128 到 127 的范围，所以i3和i4是两个不同的Integer对象，i3 &#x3D;&#x3D; i4会返回false。\n代码：\nFloat i11 = 333f;Float i22 = 333f;System.out.println(i11 == i22);\n解释：Float无缓存机制，将会输出false\nJava装箱拆箱装箱其实就是调用了包装类的valueOf()方法，表示输入任何类型转换成该类型。而拆箱其实就是调用了xxxValue()方法。代码：\nInteger i = 129;  //装箱int n = i;   //拆箱System.out.println(n == i);\n解释：n 和 i 是引用的同一个，输出true\n"},{"title":"个人博客教程","url":"/qxblog.github.io/2025/04/13/blog/","content":"","categories":["配置"],"tags":["配置","qxblog"]},{"title":"Hello World","url":"/qxblog.github.io/2025/04/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]